package com.example.hrm.ai;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.RoundingMode;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.math.BigDecimal;
import java.util.stream.Collectors;

@Service
public class HRMResponseFormatter {

    private static final Logger log = LoggerFactory.getLogger(HRMResponseFormatter.class);
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy");

    @Autowired
    private HRMPermissionService permissionService;

    // ‚úÖ SAFE PARSING METHODS - Fix all NumberFormatException
    private int safeParseInt(Object value) {
        if (value == null) return 0;
        try {
            if (value instanceof Number) return ((Number) value).intValue();
            String str = value.toString().trim();
            if ("N/A".equals(str) || str.isEmpty()) return 0;
            return Integer.parseInt(str);
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot parse as int: '{}', returning 0", value);
            return 0;
        }
    }

    private double safeParseDouble(Object value) {
        if (value == null) return 0.0;
        try {
            if (value instanceof Number) return ((Number) value).doubleValue();
            String str = value.toString().trim();
            if ("N/A".equals(str) || str.isEmpty()) return 0.0;
            return Double.parseDouble(str);
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot parse as double: '{}', returning 0.0", value);
            return 0.0;
        }
    }

    private long safeParseLong(Object value) {
        if (value == null) return 0L;
        try {
            if (value instanceof Number) return ((Number) value).longValue();
            String str = value.toString().trim();
            if ("N/A".equals(str) || str.isEmpty()) return 0L;
            return Long.parseLong(str);
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot parse as long: '{}', returning 0", value);
            return 0L;
        }
    }

    private String safeGetString(Object value) {
        return (value != null) ? value.toString() : "N/A";
    }

    private String safeGetString(Map<String, Object> map, String key) {
        Object value = map.get(key);
        return (value != null) ? value.toString() : "N/A";
    }

    public String formatResponse(DatabaseResponse dbResponse) {
        if (!dbResponse.isSuccess()) {
            return "‚ùå " + dbResponse.getError();
        }

        List<Map<String, Object>> data = dbResponse.getData();
        if (data.isEmpty()) {
            return generateEmptyResultMessage(dbResponse.getQueryType());
        }

        String userName = permissionService.getCurrentUserName();

        return switch (dbResponse.getQueryType()) {
            // Personal queries
            case MY_INFO -> formatEmployeeInfo(data, userName);
            case MY_SALARY -> formatSalaryInfo(data, userName);
            case MY_ATTENDANCE -> formatAttendanceInfo(data, userName);
            case MY_LEAVE -> formatLeaveInfo(data, userName);
            case MY_CONTRACT -> formatContractInfo(data, userName);
            case MY_ALLOWANCE -> formatAllowanceInfo(data, userName);
            case MY_BONUS -> formatBonusInfo(data, userName);
            case MY_VIOLATION -> formatViolationInfo(data, userName);
            case TEAM_INFO -> formatTeamInfo(data);

            // Admin queries - SAFE VERSIONS
            case EMPLOYEE_SEARCH -> formatEmployeeSearchResult(data);
            case ADMIN_ALL_EMPLOYEES -> formatAllEmployeesReport(data);
            case ADMIN_DEPARTMENT_REPORT -> formatDepartmentReportSafe(data);
            case ADMIN_SALARY_ANALYSIS -> formatSalaryAnalysisSafe(data);
            case ADMIN_ATTENDANCE_REPORT -> formatAttendanceReportSafe(data);
            case ADMIN_COMPANY_STATS -> formatCompanyStatsSafe(data);
            case ADMIN_FINANCIAL_ANALYSIS -> formatFinancialAnalysisSafe(data);
            case ADMIN_CONTRACT_INFO -> formatAdminContractInfo(data);
            case ADMIN_CONTRACT_REPORT -> formatContractReportSafe(data, dbResponse);

            // AI Generated with smart detection
            case AI_GENERATED -> formatAIGeneratedResponseSmart(data, dbResponse);
            default -> formatGenericResponseSafe(data, dbResponse);
        };
    }

    // ‚úÖ SAFE DEPARTMENT REPORT (Fix line 315 error)
    private String formatDepartmentReportSafe(List<Map<String, Object>> data) {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append("üè¢ **B√ÅO C√ÅO PH√íNG BAN**\n\n");

            BigDecimal grandTotal = BigDecimal.ZERO;
            int totalEmployees = 0;

            for (Map<String, Object> dept : data) {
                String tenPhongBan = safeGetString(dept.get("TenPhongBan"));

                // Handle different possible column names for overtime hours
                Object tongGioTangCa = dept.get("TongSoGioTangCa");
                if (tongGioTangCa == null) tongGioTangCa = dept.get("TongSoGioTangCa");
                if (tongGioTangCa == null) tongGioTangCa = dept.get("TongGioTangCa");

                // Safe parsing for various fields
                Object deptTotal = dept.get("TongLuong");
                Object deptAvg = dept.get("LuongTrungBinh");
                Object deptMin = dept.get("LuongThapNhat");
                Object deptMax = dept.get("LuongCaoNhat");
                Object empCount = dept.get("SoNhanVien");

                int employees = safeParseInt(empCount);
                totalEmployees += employees;

                BigDecimal deptTotalBD = getBigDecimal(deptTotal);
                grandTotal = grandTotal.add(deptTotalBD);

                if (tongGioTangCa != null) {
                    // Overtime report
                    sb.append(String.format("""
                        üè¢ **%s**
                        ‚îú‚îÄ ‚è∞ T·ªïng gi·ªù tƒÉng ca: %s gi·ªù
                        ‚îú‚îÄ üë• Nh√¢n vi√™n: %d ng∆∞·ªùi
                        ‚îî‚îÄ üìä TB tƒÉng ca/ng∆∞·ªùi: %.1f gi·ªù
                        
                        """,
                            tenPhongBan,
                            formatNumber(tongGioTangCa),
                            employees,
                            employees > 0 ? safeParseDouble(tongGioTangCa) / employees : 0.0
                    ));
                } else {
                    // Salary report
                    sb.append(String.format("""
                        üè¢ **%s**
                        ‚îú‚îÄ üë• S·ªë nh√¢n vi√™n: %d ng∆∞·ªùi
                        ‚îú‚îÄ üí∞ L∆∞∆°ng trung b√¨nh: %s VNƒê
                        ‚îú‚îÄ üìà L∆∞∆°ng cao nh·∫•t: %s VNƒê
                        ‚îú‚îÄ üìâ L∆∞∆°ng th·∫•p nh·∫•t: %s VNƒê
                        ‚îú‚îÄ üíµ T·ªïng l∆∞∆°ng ph√≤ng ban: %s VNƒê  
                        ‚îî‚îÄ üìä %% t·ªïng chi ph√≠: %.1f%%
                        
                        """,
                            tenPhongBan,
                            employees,
                            formatCurrency(deptAvg),
                            formatCurrency(deptMax),
                            formatCurrency(deptMin),
                            formatCurrency(deptTotalBD),
                            grandTotal.compareTo(BigDecimal.ZERO) > 0 ?
                                    deptTotalBD.multiply(BigDecimal.valueOf(100)).divide(grandTotal, 1, BigDecimal.ROUND_HALF_UP).doubleValue() : 0.0
                    ));
                }
            }

            sb.append(String.format("""
                üìä **T·ªîNG K·∫æT:**
                ‚îú‚îÄ üè¢ T·ªïng s·ªë ph√≤ng ban: %d ph√≤ng
                ‚îú‚îÄ üë• T·ªïng nh√¢n vi√™n: %d ng∆∞·ªùi
                ‚îî‚îÄ üí∞ T·ªïng chi ph√≠: %s VNƒê
                """,
                    data.size(),
                    totalEmployees,
                    formatCurrency(grandTotal)
            ));

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatDepartmentReportSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, null);
        }
    }
    // ‚úÖ SAFE CONTRACT REPORT FORMATTER
    private String formatContractReportSafe(List<Map<String, Object>> data, DatabaseResponse dbResponse) {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append("üìã **DANH S√ÅCH H·ª¢P ƒê·ªíNG**\n\n");

            if (data.isEmpty()) {
                sb.append("üì≠ Kh√¥ng t√¨m th·∫•y h·ª£p ƒë·ªìng n√†o.\n");
                return sb.toString();
            }

            // Check if this is expiring contracts
            boolean isExpiringReport = data.stream()
                    .anyMatch(record -> record.containsKey("SoNgayConLai"));

            if (isExpiringReport) {
                sb.append("‚è∞ **H·ª¢P ƒê·ªíNG S·∫ÆP H·∫æT H·∫†N**\n\n");

                // Group by urgency
                List<Map<String, Object>> urgent = data.stream()
                        .filter(r -> safeParseInt(r.get("SoNgayConLai")) <= 30)
                        .collect(Collectors.toList());

                List<Map<String, Object>> warning = data.stream()
                        .filter(r -> {
                            int days = safeParseInt(r.get("SoNgayConLai"));
                            return days > 30 && days <= 90;
                        })
                        .collect(Collectors.toList());

                if (!urgent.isEmpty()) {
                    sb.append("üö® **KH·∫®N C·∫§P (‚â§ 30 ng√†y):**\n");
                    urgent.forEach(record -> sb.append(formatSingleContract(record, true)));
                    sb.append("\n");
                }

                if (!warning.isEmpty()) {
                    sb.append("‚ö†Ô∏è **C·∫¢nh B√ÅO (31-90 ng√†y):**\n");
                    warning.forEach(record -> sb.append(formatSingleContract(record, true)));
                    sb.append("\n");
                }

                // Summary
                sb.append(String.format("""
                üìä **T·ªîNG K·∫æT:**
                ‚îú‚îÄ üö® Kh·∫©n c·∫•p: %d h·ª£p ƒë·ªìng
                ‚îú‚îÄ ‚ö†Ô∏è C·∫£nh b√°o: %d h·ª£p ƒë·ªìng  
                ‚îî‚îÄ üìã T·ªïng c·ªông: %d h·ª£p ƒë·ªìng
                
                üí° **KHUY·∫æN NGH·ªä:** Li√™n h·ªá v·ªõi c√°c nh√¢n vi√™n c√≥ h·ª£p ƒë·ªìng s·∫Øp h·∫øt h·∫°n ƒë·ªÉ gia h·∫°n ho·∫∑c th∆∞∆°ng th·∫£o ƒëi·ªÅu kho·∫£n m·ªõi.
                """, urgent.size(), warning.size(), data.size()));

            } else {
                // Regular contract list
                for (int i = 0; i < Math.min(data.size(), 20); i++) {
                    Map<String, Object> record = data.get(i);
                    sb.append(formatSingleContract(record, false));
                }

                if (data.size() > 20) {
                    sb.append(String.format("... v√† %d h·ª£p ƒë·ªìng kh√°c\n", data.size() - 20));
                }

                sb.append(String.format("\nüìä **T·ªïng c·ªông:** %d h·ª£p ƒë·ªìng\n", data.size()));
            }

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatContractReportSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, dbResponse);
        }
    }

    // ‚úÖ FORMAT SINGLE CONTRACT
    private String formatSingleContract(Map<String, Object> record, boolean showDaysLeft) {
        try {
            String maHopDong = safeGetString(record.get("MaHopDong"));
            String hoTen = safeGetString(record.get("HoTen"));
            String loaiHopDong = safeGetString(record.get("LoaiHopDong"));
            String ngayBatDau = formatDateSafe(record.get("NgayBatDau"));
            String ngayKetThuc = formatDateSafe(record.get("NgayKetThuc"));
            BigDecimal luongCoBan = getBigDecimal(record.get("LuongCoBan"));

            StringBuilder sb = new StringBuilder();

            if (showDaysLeft) {
                int soNgayConLai = safeParseInt(record.get("SoNgayConLai"));
                String urgencyIcon = soNgayConLai <= 7 ? "üî¥" :
                        soNgayConLai <= 30 ? "üü°" : "üü¢";

                sb.append(String.format("üìã **%s** %s\n", maHopDong, urgencyIcon));
                sb.append(String.format("‚îú‚îÄ üë§ Nh√¢n vi√™n: %s\n", hoTen));
                sb.append(String.format("‚îú‚îÄ üìù Lo·∫°i: %s\n", loaiHopDong));
                sb.append(String.format("‚îú‚îÄ üìÖ K·∫øt th√∫c: %s\n", ngayKetThuc));
                sb.append(String.format("‚îú‚îÄ ‚è∞ C√≤n l·∫°i: %d ng√†y\n", soNgayConLai));
                sb.append(String.format("‚îî‚îÄ üí∞ L∆∞∆°ng: %s VNƒê\n\n", formatCurrency(luongCoBan)));
            } else {
                sb.append(String.format("üìã **%s**\n", maHopDong));
                sb.append(String.format("‚îú‚îÄ üë§ Nh√¢n vi√™n: %s\n", hoTen));
                sb.append(String.format("‚îú‚îÄ üìù Lo·∫°i: %s\n", loaiHopDong));
                sb.append(String.format("‚îú‚îÄ üìÖ T·ª´: %s ‚Üí %s\n", ngayBatDau, ngayKetThuc));
                sb.append(String.format("‚îî‚îÄ üí∞ L∆∞∆°ng: %s VNƒê\n\n", formatCurrency(luongCoBan)));
            }

            return sb.toString();
        } catch (Exception e) {
            return "‚ùå L·ªói hi·ªÉn th·ªã h·ª£p ƒë·ªìng\n";
        }
    }
    // ‚úÖ SAFE SALARY ANALYSIS (Fix line 278 error)
    private String formatSalaryAnalysisSafe(List<Map<String, Object>> data) {
        try {
            StringBuilder sb = new StringBuilder();

            // Detect if this is bonus/reward data or salary data
            Map<String, Object> firstRecord = data.get(0);
            boolean isBonusData = firstRecord.containsKey("TenThuong") || firstRecord.containsKey("MucThuong");
            boolean isTopSalary = firstRecord.containsKey("TongThuNhap");

            if (isBonusData) {
                sb.append("üéâ **PH√ÇN T√çCH TH∆Ø·ªûNG**\n\n");

                BigDecimal totalBonus = BigDecimal.ZERO;
                int bonusCount = 0;

                for (Map<String, Object> record : data) {
                    String hoTen = safeGetString(record.get("HoTen"));
                    String phongBan = safeGetString(record.get("TenPhongBan"));
                    String tenThuong = safeGetString(record.get("TenThuong"));
                    Object mucThuong = record.get("MucThuong");
                    Object ngayThuong = record.get("NgayThuong");
                    Object maNhanVien = record.get("MaNhanVien");
                    Object tongTienThuong = record.get("TongTienThuong");

                    BigDecimal bonusAmount = getBigDecimal(mucThuong != null ? mucThuong : tongTienThuong);
                    totalBonus = totalBonus.add(bonusAmount);
                    bonusCount++;

                    sb.append(String.format("""
                        üèÜ **%s** (%s)
                        ‚îú‚îÄ üè¢ Ph√≤ng ban: %s
                        ‚îú‚îÄ üéÅ Lo·∫°i th∆∞·ªüng: %s
                        ‚îú‚îÄ üí∞ S·ªë ti·ªÅn: %s VNƒê
                        ‚îî‚îÄ üìÖ Ng√†y th∆∞·ªüng: %s
                        
                        """,
                            hoTen,
                            safeGetString(maNhanVien),
                            phongBan,
                            tenThuong,
                            formatCurrency(bonusAmount),
                            formatDate(ngayThuong)
                    ));
                }

                sb.append(String.format("""
                    üìä **T·ªîNG K·∫æT:**
                    ‚îú‚îÄ üéâ S·ªë l∆∞·ª£t th∆∞·ªüng: %d
                    ‚îú‚îÄ üí∞ T·ªïng ti·ªÅn th∆∞·ªüng: %s VNƒê
                    ‚îî‚îÄ üìä Th∆∞·ªüng trung b√¨nh: %s VNƒê
                    """,
                        bonusCount,
                        formatCurrency(totalBonus),
                        bonusCount > 0 ? formatCurrency(totalBonus.divide(BigDecimal.valueOf(bonusCount), 0, BigDecimal.ROUND_HALF_UP)) : "0"
                ));

            } else if (isTopSalary) {
                sb.append("üí∞ **PH√ÇN T√çCH TOP L∆Ø∆†NG**\n\n");

                BigDecimal totalSalary = BigDecimal.ZERO;
                int rank = 1;

                for (Map<String, Object> record : data) {
                    BigDecimal salary = getBigDecimal(record.get("TongThuNhap"));
                    totalSalary = totalSalary.add(salary);

                    String medal = switch (rank) {
                        case 1 -> "ü•á";
                        case 2 -> "ü•à";
                        case 3 -> "ü•â";
                        default -> "üèÜ";
                    };

                    sb.append(String.format("""
                        %s **#%d - %s**
                        ‚îú‚îÄ üí∞ L∆∞∆°ng: %s VNƒê
                        ‚îú‚îÄ üè¢ Ph√≤ng ban: %s
                        ‚îú‚îÄ üìÖ Th√°ng: %s/%s
                        ‚îî‚îÄ üÜî M√£ NV: %s
                        
                        """,
                            medal, rank,
                            safeGetString(record.get("HoTen")),
                            formatCurrency(salary),
                            safeGetString(record.get("TenPhongBan")),
                            safeGetString(record.get("Thang")),
                            safeGetString(record.get("Nam")),
                            safeGetString(record.get("MaNhanVien"))
                    ));
                    rank++;
                }

                if (data.size() > 0) {
                    BigDecimal avgSalary = totalSalary.divide(BigDecimal.valueOf(data.size()), 0, BigDecimal.ROUND_HALF_UP);
                    sb.append(String.format("""
                        üìä **TH·ªêNG K√ä:**
                        ‚îú‚îÄ üíµ T·ªïng l∆∞∆°ng: %s VNƒê
                        ‚îú‚îÄ üìä L∆∞∆°ng trung b√¨nh: %s VNƒê
                        ‚îî‚îÄ üë• S·ªë nh√¢n vi√™n: %d ng∆∞·ªùi
                        """,
                            formatCurrency(totalSalary),
                            formatCurrency(avgSalary),
                            data.size()
                    ));
                }
            } else {
                // Generic salary analysis
                sb.append("üí∞ **PH√ÇN T√çCH L∆Ø∆†NG KH√ÅC**\n\n");

                for (Map<String, Object> record : data) {
                    sb.append("üìä ");
                    for (Map.Entry<String, Object> entry : record.entrySet()) {
                        String key = translateColumnName(entry.getKey());
                        Object value = entry.getValue();
                        sb.append(String.format("**%s:** %s | ", key, formatValueSafe(value)));
                    }
                    sb.append("\n\n");
                }
            }

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatSalaryAnalysisSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, null);
        }
    }
    // ‚úÖ ADD this method to fix compile errors
    private String formatDateSafe(Object dateObj) {
        try {
            if (dateObj == null) return "N/A";

            // Handle LocalDate
            if (dateObj instanceof LocalDate) {
                return ((LocalDate) dateObj).format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            }

            // Handle LocalDateTime
            if (dateObj instanceof LocalDateTime) {
                return ((LocalDateTime) dateObj).format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            }

            // Handle java.sql.Date
            if (dateObj instanceof java.sql.Date) {
                return ((java.sql.Date) dateObj).toLocalDate()
                        .format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            }

            // Handle java.sql.Timestamp
            if (dateObj instanceof java.sql.Timestamp) {
                return ((java.sql.Timestamp) dateObj).toLocalDateTime().toLocalDate()
                        .format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            }

            // Handle java.util.Date
            if (dateObj instanceof java.util.Date) {
                return new java.sql.Date(((java.util.Date) dateObj).getTime())
                        .toLocalDate().format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
            }

            // Try to parse string format
            String dateStr = dateObj.toString();
            if (dateStr.length() >= 10) {
                try {
                    return LocalDate.parse(dateStr.substring(0, 10))
                            .format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
                } catch (Exception e) {
                    // Try alternative parsing
                    return dateStr.substring(0, 10);
                }
            }

            return dateStr;
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot format date: {} - Error: {}", dateObj, e.getMessage());
            return "N/A";
        }
    }
    // ‚úÖ FIXED FINANCIAL ANALYSIS - Dynamic month detection
    private String formatFinancialAnalysisSafe(List<Map<String, Object>> data) {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append("üí∏ **PH√ÇN T√çCH T√ÄI CH√çNH**\n\n");

            if (!data.isEmpty()) {
                Map<String, Object> record = data.get(0);

                // Handle total fine amount
                Object tongTienPhat = record.get("TongTienPhat");
                if (tongTienPhat != null) {
                    BigDecimal fineAmount = getBigDecimal(tongTienPhat);

                    sb.append(String.format("üí∏ **T·ªïng ti·ªÅn ph·∫°t:** %s VNƒê\n", formatCurrency(fineAmount)));

                    if (fineAmount.compareTo(BigDecimal.valueOf(1000000)) > 0) {
                        sb.append("‚ö†Ô∏è *M·ª©c ph·∫°t cao, c·∫ßn xem x√©t c√°c bi·ªán ph√°p c·∫£i thi·ªán*\n");
                    } else if (fineAmount.compareTo(BigDecimal.ZERO) == 0) {
                        sb.append("‚úÖ *Kh√¥ng c√≥ vi ph·∫°m n√†o ƒë∆∞·ª£c ghi nh·∫≠n*\n");
                    } else {
                        sb.append("üü° *M·ª©c ph·∫°t ·ªü m·ª©c ch·∫•p nh·∫≠n ƒë∆∞·ª£c*\n");
                    }
                } else {
                    // Handle comprehensive financial analysis
                    Object tongChiPhi = record.get("TongChiPhiLuong");
                    Object luongTB = record.get("LuongTrungBinh");
                    Object soNhanVien = record.get("SoNhanVien");
                    Object tongTangCa = record.get("TongTienTangCa");
                    Object tongThue = record.get("TongThue");

                    BigDecimal totalCost = getBigDecimal(tongChiPhi);
                    BigDecimal avgSalary = getBigDecimal(luongTB);
                    int employees = safeParseInt(soNhanVien);
                    BigDecimal totalOvertime = getBigDecimal(tongTangCa);
                    BigDecimal totalTax = getBigDecimal(tongThue);

                    BigDecimal costPerEmployee = employees > 0 ?
                            totalCost.divide(BigDecimal.valueOf(employees), 0, RoundingMode.HALF_UP) :
                            BigDecimal.ZERO;

                    double overtimeRatio = totalCost.compareTo(BigDecimal.ZERO) > 0 ?
                            totalOvertime.multiply(BigDecimal.valueOf(100)).divide(totalCost, 2, RoundingMode.HALF_UP).doubleValue() : 0.0;

                    // ‚úÖ DYNAMIC MONTH/YEAR DETECTION
                    String periodLabel = detectPeriodFromData(record);

                    sb.append(String.format("""
                    üíµ **CHI PH√ç %s:**
                    ‚îú‚îÄ üí∞ T·ªïng chi ph√≠ l∆∞∆°ng: %s VNƒê
                    ‚îú‚îÄ üìä L∆∞∆°ng trung b√¨nh: %s VNƒê
                    ‚îú‚îÄ üë• S·ªë nh√¢n vi√™n: %d ng∆∞·ªùi
                    ‚îú‚îÄ ‚è∞ T·ªïng ti·ªÅn tƒÉng ca: %s VNƒê
                    ‚îú‚îÄ üèõÔ∏è T·ªïng thu·∫ø thu nh·∫≠p: %s VNƒê
                    ‚îî‚îÄ üìà Chi ph√≠ TB/ng∆∞·ªùi: %s VNƒê
                    
                    üìä **PH√ÇN T√çCH:**
                    ‚îú‚îÄ T·ª∑ l·ªá overtime: %.1f%%
                    ‚îú‚îÄ ƒê√°nh gi√° overtime: %s
                    ‚îî‚îÄ Chi ph√≠/ng∆∞·ªùi: %s
                    
                    üí° **KHUY·∫æN NGH·ªä:**
                    %s
                    
                    üìÖ *C·∫≠p nh·∫≠t: %s*
                    """,
                            periodLabel,
                            formatCurrency(totalCost),
                            formatCurrency(avgSalary),
                            employees,
                            formatCurrency(totalOvertime),
                            formatCurrency(totalTax),
                            formatCurrency(costPerEmployee),
                            overtimeRatio,
                            getOvertimeAssessment(overtimeRatio),
                            getCostAssessment(costPerEmployee),
                            getRecommendation(overtimeRatio, costPerEmployee),
                            LocalDate.now().format(DATE_FORMATTER)
                    ));
                }
            }

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatFinancialAnalysisSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, null);
        }
    }

    // ‚úÖ NEW METHOD: Detect period from data or context
    private String detectPeriodFromData(Map<String, Object> record) {
        try {
            // Try to detect from SQL context (stored in thread local or similar)
            String currentQuery = getCurrentSQLQuery(); // You'll need to implement this
            if (currentQuery != null) {
                // Extract month/year from SQL: "WHERE Thang = 4 AND Nam = 2025"
                if (currentQuery.contains("Thang = ") && currentQuery.contains("Nam = ")) {
                    String month = extractValueAfter(currentQuery, "Thang = ");
                    String year = extractValueAfter(currentQuery, "Nam = ");
                    if (month != null && year != null) {
                        return String.format("TH√ÅNG %s/%s", month, year);
                    }
                }
            }

            // Fallback: Check if data contains month/year info
            Object thang = record.get("Thang");
            Object nam = record.get("Nam");
            if (thang != null && nam != null) {
                return String.format("TH√ÅNG %s/%s", thang, nam);
            }

            // Default fallback
            return "HI·ªÜN T·∫†I";

        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot detect period, using default");
            return "HI·ªÜN T·∫†I";
        }
    }

    // ‚úÖ HELPER METHODS
    private String getCurrentSQLQuery() {
        // TODO: Implement thread-local storage for current SQL
        // For now, return null - you can store this in ThreadLocal or request context
        return null;
    }

    private String extractValueAfter(String text, String pattern) {
        try {
            int index = text.indexOf(pattern);
            if (index != -1) {
                String after = text.substring(index + pattern.length()).trim();
                // Extract number until space or AND
                String[] parts = after.split("\\s+");
                if (parts.length > 0) {
                    return parts[0];
                }
            }
            return null;
        } catch (Exception e) {
            return null;
        }
    }

    // ‚úÖ SAFE ATTENDANCE REPORT
    private String formatAttendanceReportSafe(List<Map<String, Object>> data) {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append("üìä **B√ÅO C√ÅO CH·∫§M C√îNG**\n\n");

            int rank = 1;
            for (Map<String, Object> record : data) {
                String hoTen = safeGetString(record.get("HoTen"));
                String phongBan = safeGetString(record.get("TenPhongBan"));
                Object soLanViPham = record.get("SoLanViPham");
                if (soLanViPham == null) soLanViPham = record.get("SoLanMuon");

                int violationCount = safeParseInt(soLanViPham);
                String severity = getLateSeverity(violationCount);

                String rankEmoji = switch (rank) {
                    case 1 -> "ü•á";
                    case 2 -> "ü•à";
                    case 3 -> "ü•â";
                    default -> "‚ö†Ô∏è";
                };

                sb.append(String.format("""
                    %s **#%d - %s**
                    ‚îú‚îÄ üè¢ Ph√≤ng ban: %s
                    ‚îú‚îÄ üÜî M√£ NV: %s  
                    ‚îú‚îÄ üìä S·ªë l·∫ßn vi ph·∫°m: %d l·∫ßn
                    ‚îî‚îÄ üö® M·ª©c ƒë·ªô: %s
                    
                    """,
                        rankEmoji,
                        rank,
                        hoTen,
                        phongBan,
                        safeGetString(record.get("MaNhanVien")),
                        violationCount,
                        severity
                ));
                rank++;
            }

            int needAttention = (int) data.stream().mapToInt(r -> safeParseInt(r.get("SoLanViPham") != null ? r.get("SoLanViPham") : r.get("SoLanMuon"))).filter(x -> x >= 5).count();
            int serious = (int) data.stream().mapToInt(r -> safeParseInt(r.get("SoLanViPham") != null ? r.get("SoLanViPham") : r.get("SoLanMuon"))).filter(x -> x >= 10).count();

            sb.append(String.format("""
                üìà **TH·ªêNG K√ä:**
                ‚îú‚îÄ üë• T·ªïng nh√¢n vi√™n vi ph·∫°m: %d ng∆∞·ªùi
                ‚îú‚îÄ ‚ö†Ô∏è C·∫ßn ch√∫ √Ω (‚â•5 l·∫ßn): %d ng∆∞·ªùi
                ‚îî‚îÄ üö® Nghi√™m tr·ªçng (‚â•10 l·∫ßn): %d ng∆∞·ªùi
                
                üí° **KHUY·∫æN NGH·ªä:** C·∫ßn c√≥ bi·ªán ph√°p qu·∫£n l√Ω ch·∫•m c√¥ng t·ªët h∆°n.
                """,
                    data.size(),
                    needAttention,
                    serious
            ));

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatAttendanceReportSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, null);
        }
    }

    // ‚úÖ SAFE COMPANY STATS
    private String formatCompanyStatsSafe(List<Map<String, Object>> data) {
        try {
            StringBuilder sb = new StringBuilder();
            sb.append("üè¢ **TH·ªêNG K√ä T·ªîNG QUAN C√îNG TY**\n\n");

            for (Map<String, Object> stat : data) {
                String metric = safeGetString(stat.get("Metric"));
                Object value = stat.get("Value");

                String emoji = switch (metric) {
                    case "TongNhanVien" -> "üë•";
                    case "TongPhongBan" -> "üè¢";
                    case "LuongTrungBinh" -> "üí∞";
                    case "TongChiPhiLuong" -> "üíµ";
                    default -> "üìä";
                };

                String displayName = switch (metric) {
                    case "TongNhanVien" -> "T·ªïng nh√¢n vi√™n ƒëang l√†m vi·ªác";
                    case "TongPhongBan" -> "T·ªïng s·ªë ph√≤ng ban";
                    case "LuongTrungBinh" -> "L∆∞∆°ng trung b√¨nh th√°ng 6/2025";
                    case "TongChiPhiLuong" -> "T·ªïng chi ph√≠ l∆∞∆°ng th√°ng 6/2025";
                    default -> metric;
                };

                String formattedValue = metric.contains("Luong") ? formatCurrency(value) : formatNumber(value);
                String unit = metric.contains("Luong") ? " VNƒê" :
                        metric.equals("TongNhanVien") ? " ng∆∞·ªùi" :
                                metric.equals("TongPhongBan") ? " ph√≤ng" : "";

                sb.append(String.format("%s **%s:** %s%s\n", emoji, displayName, formattedValue, unit));
            }

            sb.append(String.format("""
                
                üìà **ƒê√ÅNH GI√Å:**
                ‚îú‚îÄ üü¢ T√¨nh h√¨nh nh√¢n s·ª±: ·ªîn ƒë·ªãnh
                ‚îú‚îÄ üíº C∆° c·∫•u t·ªï ch·ª©c: ƒê·∫ßy ƒë·ªß
                ‚îî‚îÄ üí∞ Chi ph√≠ l∆∞∆°ng: Trong t·∫ßm ki·ªÉm so√°t
                
                üìÖ *C·∫≠p nh·∫≠t: %s*
                """,
                    LocalDate.now().format(DATE_FORMATTER)
            ));

            return sb.toString();
        } catch (Exception e) {
            log.error("‚ùå formatCompanyStatsSafe error: {}", e.getMessage());
            return formatGenericResponseSafe(data, null);
        }
    }

    // ‚úÖ SMART AI RESPONSE (Auto-detect data type)
    private String formatAIGeneratedResponseSmart(List<Map<String, Object>> data, DatabaseResponse dbResponse) {
        if (data.isEmpty()) {
            return "üì≠ Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu.";
        }

        Map<String, Object> firstRow = data.get(0);

        // Contract data detection
        if (firstRow.containsKey("MaHopDong") || firstRow.containsKey("LoaiHopDong") ||
                firstRow.containsKey("NgayBatDau") || firstRow.containsKey("NgayKetThuc")) {
            log.info("üîß AUTO-DETECT: Contract data found");
            return formatContractDataSmart(data);
        }

        // Salary data detection
        if (firstRow.containsKey("TongThuNhap") || firstRow.containsKey("TienTangCa")) {
            log.info("üîß AUTO-DETECT: Salary data found");
            return formatSalaryInfo(data, permissionService.getCurrentUserName());
        }

        // Employee data detection
        if (firstRow.containsKey("HoTen") && firstRow.containsKey("Email")) {
            log.info("üîß AUTO-DETECT: Employee data found");
            return formatEmployeeSearchResult(data);
        }

        // Default generic formatting
        log.info("üîß AUTO-DETECT: Using generic formatting");
        return formatGenericResponseSafe(data, dbResponse);
    }

    // ‚úÖ SMART CONTRACT FORMATTING
    private String formatContractDataSmart(List<Map<String, Object>> data) {
        StringBuilder sb = new StringBuilder();
        sb.append("üìã **TH√îNG TIN H·ª¢P ƒê·ªíNG**\n\n");

        for (Map<String, Object> contract : data) {
            String trangThai = safeGetString(contract.get("TrangThai"));
            String emoji = switch (trangThai.toLowerCase()) {
                case "c√≤n hi·ªáu l·ª±c", "con hieu luc", "active" -> "‚úÖ";
                case "h·∫øt h·∫°n", "het han", "expired" -> "‚è∞";
                case "ch·∫•m d·ª©t", "cham dut", "terminated" -> "‚ùå";
                default -> "üìÑ";
            };

            sb.append(String.format("""
                üìÑ **H·ª£p ƒë·ªìng #%s** %s
                ‚îú‚îÄ üë§ M√£ nh√¢n vi√™n: %s
                ‚îú‚îÄ üë§ T√™n nh√¢n vi√™n: %s
                ‚îú‚îÄ üìã Lo·∫°i h·ª£p ƒë·ªìng: %s
                ‚îú‚îÄ üìÖ Ng√†y b·∫Øt ƒë·∫ßu: %s
                ‚îú‚îÄ üìÖ Ng√†y k·∫øt th√∫c: %s
                ‚îú‚îÄ üí∞ L∆∞∆°ng c∆° b·∫£n: %s VNƒê
                ‚îî‚îÄ üìä Tr·∫°ng th√°i: %s %s
                
                """,
                    safeGetString(contract.get("MaHopDong")),
                    emoji,
                    safeGetString(contract.get("MaNhanVien")),
                    safeGetString(contract.get("HoTen")),
                    safeGetString(contract.get("LoaiHopDong")),
                    formatDate(contract.get("NgayBatDau")),
                    formatDate(contract.get("NgayKetThuc")),
                    formatCurrency(contract.get("LuongCoBan")),
                    trangThai,
                    emoji
            ));
        }

        if (data.size() > 1) {
            sb.append(String.format("üìä **T·ªïng c·ªông:** %d h·ª£p ƒë·ªìng\n", data.size()));
        }

        return sb.toString();
    }

    // ‚úÖ GENERIC SAFE FORMATTER
    private String formatGenericResponseSafe(List<Map<String, Object>> data, DatabaseResponse dbResponse) {
        StringBuilder sb = new StringBuilder();
        sb.append("ü§ñ **K·∫æT QU·∫¢ T√åM KI·∫æM**\n\n");

        if (data.size() == 1) {
            // Single record - detailed view
            Map<String, Object> record = data.get(0);
            for (Map.Entry<String, Object> entry : record.entrySet()) {
                String key = translateColumnName(entry.getKey());
                Object value = entry.getValue();
                sb.append(String.format("‚îú‚îÄ **%s:** %s\n", key, formatValueSafe(value)));
            }
        } else {
            // Multiple records - summary view
            sb.append(String.format("üìä **T√¨m th·∫•y %d k·∫øt qu·∫£:**\n\n", data.size()));

            int count = 1;
            for (Map<String, Object> record : data) {
                sb.append(String.format("**%d.** ", count++));

                // Show key fields
                for (Map.Entry<String, Object> entry : record.entrySet()) {
                    if (isKeyField(entry.getKey())) {
                        sb.append(String.format("%s: %s | ",
                                translateColumnName(entry.getKey()),
                                formatValueSafe(entry.getValue())));
                    }
                }
                sb.append("\n");

                if (count > 15) {
                    sb.append(String.format("... v√† %d k·∫øt qu·∫£ kh√°c\n", data.size() - 15));
                    break;
                }
            }
        }

        return sb.toString();
    }

    private String formatValueSafe(Object value) {
        if (value == null) return "N/A";
        if (value instanceof Number) {
            return formatNumber(value);
        }
        return value.toString();
    }

    private String formatNumber(Object value) {
        if (value == null) return "0";
        double num = safeParseDouble(value);
        return String.format("%,.0f", num);
    }

    private String generateEmptyResultMessage(QueryType queryType) {
        return switch (queryType) {
            case MY_SALARY -> "üí∞ Ch∆∞a c√≥ th√¥ng tin l∆∞∆°ng cho th·ªùi gian n√†y.";
            case MY_ATTENDANCE -> "üìä Ch∆∞a c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng.";
            case MY_LEAVE -> "üèñÔ∏è Ch∆∞a c√≥ ƒë∆°n ngh·ªâ ph√©p n√†o.";
            case MY_CONTRACT -> "üìã Ch∆∞a c√≥ th√¥ng tin h·ª£p ƒë·ªìng.";
            case MY_ALLOWANCE -> "üíº Ch∆∞a c√≥ th√¥ng tin ph·ª• c·∫•p.";
            case MY_BONUS -> "üéÅ Ch∆∞a c√≥ th√¥ng tin th∆∞·ªüng.";
            case MY_VIOLATION -> "‚úÖ B·∫°n ch∆∞a c√≥ vi ph·∫°m n√†o.";
            case TEAM_INFO -> "üë• Kh√¥ng t√¨m th·∫•y th√¥ng tin team.";
            case EMPLOYEE_SEARCH -> "üîç Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o ph√π h·ª£p.";
            case ADMIN_ALL_EMPLOYEES -> "üë• Kh√¥ng c√≥ nh√¢n vi√™n n√†o trong h·ªá th·ªëng.";
            case ADMIN_SALARY_ANALYSIS -> "üí∞ Kh√¥ng c√≥ d·ªØ li·ªáu l∆∞∆°ng ƒë·ªÉ ph√¢n t√≠ch.";
            case ADMIN_ATTENDANCE_REPORT -> "üìä Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng.";
            case ADMIN_COMPANY_STATS -> "üìä Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™.";
            case ADMIN_FINANCIAL_ANALYSIS -> "üí∞ Kh√¥ng c√≥ d·ªØ li·ªáu t√†i ch√≠nh.";
            default -> "üîç Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ph√π h·ª£p v·ªõi c√¢u h·ªèi c·ªßa b·∫°n.";
        };
    }

    // ===== EXISTING FORMATTERS (with safe parsing) =====

    private String formatEmployeeSearchResult(List<Map<String, Object>> data) {
        if (data.isEmpty()) {
            return "üîç Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n n√†o ph√π h·ª£p v·ªõi t√¨m ki·∫øm c·ªßa b·∫°n.";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("üîç **K·∫æT QU·∫¢ T√åM KI·∫æM NH√ÇN VI√äN**\n\n");

        if (data.size() == 1) {
            // Single result - detailed view
            Map<String, Object> emp = data.get(0);
            sb.append(formatSingleEmployeeDetail(emp));
        } else {
            // Multiple results - summary view
            sb.append(String.format("üìä **T√¨m th·∫•y %d nh√¢n vi√™n:**\n\n", data.size()));

            for (Map<String, Object> emp : data) {
                sb.append(String.format("""
                    üë§ **%s** (ID: %s)
                    ‚îú‚îÄ üìß Email: %s
                    ‚îú‚îÄ üè¢ Ph√≤ng ban: %s  
                    ‚îú‚îÄ üëî Ch·ª©c v·ª•: %s
                    ‚îî‚îÄ üìä Tr·∫°ng th√°i: %s
                    
                    """,
                        safeGetString(emp, "HoTen"),
                        safeGetString(emp, "MaNhanVien"),
                        safeGetString(emp, "Email"),
                        safeGetString(emp, "TenPhongBan"),
                        safeGetString(emp, "TenChucVu"),
                        safeGetString(emp, "TrangThaiLamViec")
                ));
            }
        }

        return sb.toString();
    }

    private String formatSingleEmployeeDetail(Map<String, Object> emp) {
        return String.format("""
            üë§ **TH√îNG TIN NH√ÇN VI√äN**
            
            üè∑Ô∏è **M√£ NV:** %s
            üìõ **H·ªç t√™n:** %s
            ‚ö• **Gi·ªõi t√≠nh:** %s
            üéÇ **Ng√†y sinh:** %s
            üìß **Email:** %s
            üì± **SƒêT:** %s
            üè† **ƒê·ªãa ch·ªâ:** %s
            üéì **Tr√¨nh ƒë·ªô:** %s
            üè¢ **Ph√≤ng ban:** %s
            üëî **Ch·ª©c v·ª•:** %s
            üí∞ **L∆∞∆°ng hi·ªán t·∫°i:** %s VNƒê
            ‚è∞ **Th√¢m ni√™n:** %s nƒÉm
            üìä **Tr·∫°ng th√°i:** %s
            
            üìÖ *Tra c·ª©u: %s*
            """,
                safeGetString(emp, "MaNhanVien"),
                safeGetString(emp, "HoTen"),
                safeGetString(emp, "GioiTinh"),
                formatDate(emp.get("NgaySinh")),
                safeGetString(emp, "Email"),
                safeGetString(emp, "SDT"),
                safeGetString(emp, "DiaChi"),
                safeGetString(emp, "TrinhDoHocVan"),
                safeGetString(emp, "TenPhongBan"),
                safeGetString(emp, "TenChucVu"),
                formatCurrency(emp.get("LuongHienTai")),
                safeGetString(emp, "ThamNien"),
                safeGetString(emp, "TrangThaiLamViec"),
                LocalDate.now().format(DATE_FORMATTER)
        );
    }

    private String formatAllEmployeesReport(List<Map<String, Object>> data) {
        StringBuilder sb = new StringBuilder();
        sb.append("üë• **DANH S√ÅCH T·∫§T C·∫¢ NH√ÇN VI√äN**\n\n");

        Map<String, Integer> deptCounts = new HashMap<>();
        Map<String, Integer> statusCounts = new HashMap<>();

        for (Map<String, Object> emp : data) {
            String trangThai = safeGetString(emp, "TrangThaiLamViec");
            String phongBan = safeGetString(emp, "TenPhongBan");

            deptCounts.merge(phongBan.isEmpty() ? "Ch∆∞a ph√¢n c√¥ng" : phongBan, 1, Integer::sum);
            statusCounts.merge(trangThai.isEmpty() ? "Kh√¥ng x√°c ƒë·ªãnh" : trangThai, 1, Integer::sum);

            sb.append(String.format("""
                üë§ **%s** (ID: %s)
                ‚îú‚îÄ üìß Email: %s
                ‚îú‚îÄ üè¢ Ph√≤ng ban: %s  
                ‚îú‚îÄ üëî Ch·ª©c v·ª•: %s
                ‚îú‚îÄ üí∞ L∆∞∆°ng: %s VNƒê
                ‚îî‚îÄ üìä Tr·∫°ng th√°i: %s %s
                
                """,
                    safeGetString(emp, "HoTen"),
                    safeGetString(emp, "MaNhanVien"),
                    safeGetString(emp, "Email"),
                    phongBan.isEmpty() ? "Ch∆∞a ph√¢n c√¥ng" : phongBan,
                    safeGetString(emp, "TenChucVu"),
                    formatCurrency(emp.get("LuongHienTai")),
                    trangThai,
                    "ƒêang l√†m vi·ªác".equals(trangThai) ? "‚úÖ" : "‚ö†Ô∏è"
            ));
        }

        sb.append(String.format("""
            üìä **TH·ªêNG K√ä T·ªîNG QUAN:**
            ‚îú‚îÄ üë• T·ªïng nh√¢n vi√™n: %d ng∆∞·ªùi
            ‚îú‚îÄ ‚úÖ ƒêang l√†m vi·ªác: %d ng∆∞·ªùi  
            ‚îú‚îÄ ‚ö†Ô∏è Ngh·ªâ vi·ªác/Kh√°c: %d ng∆∞·ªùi
            ‚îî‚îÄ üè¢ S·ªë ph√≤ng ban: %d ph√≤ng
            
            üè¢ **PH√ÇN B·ªê THEO PH√íNG BAN:**
            """,
                data.size(),
                statusCounts.getOrDefault("ƒêang l√†m vi·ªác", 0),
                data.size() - statusCounts.getOrDefault("ƒêang l√†m vi·ªác", 0),
                deptCounts.size()
        ));

        deptCounts.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .forEach(entry -> sb.append(String.format("‚îú‚îÄ %s: %d ng∆∞·ªùi\n", entry.getKey(), entry.getValue())));

        return sb.toString();
    }

    private String formatAdminContractInfo(List<Map<String, Object>> data) {
        return formatContractDataSmart(data); // Use the smart contract formatter
    }

    // ===== KEEP ALL YOUR EXISTING PERSONAL FORMATTERS =====

    private String formatEmployeeInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üë§ Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n vi√™n.";

        Map<String, Object> emp = data.get(0);

        return String.format("""
            üë§ **TH√îNG TIN C√Å NH√ÇN - %s**
            
            üè∑Ô∏è **M√£ NV:** %s
            üìõ **H·ªç t√™n:** %s
            ‚ö• **Gi·ªõi t√≠nh:** %s
            üéÇ **Ng√†y sinh:** %s
            üìß **Email:** %s
            üì± **SƒêT:** %s
            üè† **ƒê·ªãa ch·ªâ:** %s
            üéì **Tr√¨nh ƒë·ªô:** %s
            üèñÔ∏è **S·ªë ng√†y ph√©p:** %s ng√†y
            ‚è∞ **Th√¢m ni√™n:** %s nƒÉm
            üí∞ **L∆∞∆°ng hi·ªán t·∫°i:** %s VNƒê
            üìä **Tr·∫°ng th√°i:** %s
            
            üìÖ *C·∫≠p nh·∫≠t: %s*
            """,
                userName,
                safeGetString(emp, "MaNhanVien"),
                safeGetString(emp, "HoTen"),
                safeGetString(emp, "GioiTinh"),
                formatDate(emp.get("NgaySinh")),
                safeGetString(emp, "Email"),
                safeGetString(emp, "SDT"),
                safeGetString(emp, "DiaChi"),
                safeGetString(emp, "TrinhDoHocVan"),
                safeGetString(emp, "SoNgayPhep"),
                safeGetString(emp, "ThamNien"),
                formatCurrency(emp.get("LuongHienTai")),
                safeGetString(emp, "TrangThaiLamViec"),
                LocalDate.now().format(DATE_FORMATTER)
        );
    }

    private String formatSalaryInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üí∞ Ch∆∞a c√≥ th√¥ng tin l∆∞∆°ng.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üí∞ **TH√îNG TIN L∆Ø∆†NG - %s**\n\n", userName));

        BigDecimal totalSalary = BigDecimal.ZERO;

        for (Map<String, Object> salary : data) {
            BigDecimal tongThuNhap = getBigDecimal(salary.get("TongThuNhap"));
            totalSalary = totalSalary.add(tongThuNhap);

            sb.append(String.format("""
                üìÖ **Th√°ng %s/%s:**
                ‚îú‚îÄ üíµ T·ªïng thu nh·∫≠p: %s VNƒê
                ‚îú‚îÄ ‚è∞ Ti·ªÅn tƒÉng ca: %s VNƒê
                ‚îú‚îÄ üë• Ng∆∞·ªùi ph·ª• thu·ªôc: %s ng∆∞·ªùi
                ‚îú‚îÄ üèõÔ∏è Thu·∫ø thu nh·∫≠p: %s VNƒê
                ‚îî‚îÄ üìÖ Ng√†y nh·∫≠n: %s
                
                """,
                    safeGetString(salary, "Thang"),
                    safeGetString(salary, "Nam"),
                    formatCurrency(tongThuNhap),
                    formatCurrency(salary.get("TienTangCa")),
                    safeGetString(salary, "SoNguoiPhuThuoc"),
                    formatCurrency(salary.get("ThueThuNhap")),
                    formatDate(salary.get("NgayNhan"))
            ));
        }

        if (data.size() > 1) {
            sb.append(String.format("üí∞ **T·ªïng thu nh·∫≠p: %s VNƒê**", formatCurrency(totalSalary)));
        }

        return sb.toString();
    }

    private String formatAttendanceInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üìä Ch∆∞a c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üìä **CH·∫§M C√îNG - %s**\n\n", userName));

        int lateCount = 0;
        double totalOvertimeHours = 0.0;

        for (Map<String, Object> record : data) {
            String trangThai = safeGetString(record, "TrangThai");
            if ("Mu·ªôn".equals(trangThai) || "Late".equals(trangThai)) {
                lateCount++;
            }

            double overtimeHours = safeParseDouble(record.get("SoGioTangCa"));
            totalOvertimeHours += overtimeHours;

            sb.append(String.format("""
                üìÖ **%s:**
                ‚îú‚îÄ ‚è∞ V√†o: %s | Ra: %s
                ‚îú‚îÄ ‚úÖ Tr·∫°ng th√°i: %s %s
                ‚îî‚îÄ ‚è±Ô∏è TƒÉng ca: %.1f gi·ªù
                
                """,
                    formatDate(record.get("Ngay")),
                    safeGetString(record, "GioVao"),
                    safeGetString(record, "GioRa"),
                    trangThai,
                    "Mu·ªôn".equals(trangThai) || "Late".equals(trangThai) ? "‚ö†Ô∏è" : "‚úÖ",
                    overtimeHours
            ));
        }

        sb.append(String.format("""
            üìà **TH·ªêNG K√ä:**
            ‚îú‚îÄ üìä T·ªïng ng√†y: %d ng√†y
            ‚îú‚îÄ ‚ö†Ô∏è S·ªë l·∫ßn ƒëi mu·ªôn: %d l·∫ßn
            ‚îú‚îÄ üìä T·ª∑ l·ªá ƒë√∫ng gi·ªù: %.1f%%
            ‚îî‚îÄ ‚è±Ô∏è T·ªïng tƒÉng ca: %.1f gi·ªù
            """,
                data.size(),
                lateCount,
                data.size() > 0 ? (double)(data.size() - lateCount) / data.size() * 100 : 100.0,
                totalOvertimeHours
        ));

        return sb.toString();
    }

    private String formatLeaveInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üèñÔ∏è Ch∆∞a c√≥ th√¥ng tin ngh·ªâ ph√©p.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üèñÔ∏è **NGH·ªà PH√âP - %s**\n\n", userName));

        for (Map<String, Object> leave : data) {
            String trangThai = safeGetString(leave, "TrangThaiPheDuyet");
            String emoji = switch (trangThai) {
                case "ƒê√£ duy·ªát" -> "‚úÖ";
                case "Ch·ªù duy·ªát" -> "‚è≥";
                case "T·ª´ ch·ªëi" -> "‚ùå";
                default -> "üìã";
            };

            sb.append(String.format("""
                üìã **ƒê∆°n #%s:** %s
                ‚îú‚îÄ üìÖ T·ª´: %s ‚Üí %s
                ‚îú‚îÄ üìù L√Ω do: %s
                ‚îî‚îÄ üìä Tr·∫°ng th√°i: %s %s
                
                """,
                    safeGetString(leave, "MaNghiPhep"),
                    emoji,
                    formatDate(leave.get("NgayBatDau")),
                    formatDate(leave.get("NgayKetThuc")),
                    safeGetString(leave, "LyDo"),
                    trangThai,
                    emoji
            ));
        }

        return sb.toString();
    }

    private String formatContractInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üìã Ch∆∞a c√≥ th√¥ng tin h·ª£p ƒë·ªìng.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üìã **H·ª¢P ƒê·ªíNG - %s**\n\n", userName));

        for (Map<String, Object> contract : data) {
            String trangThai = safeGetString(contract, "TrangThai");
            String emoji = switch (trangThai) {
                case "C√≤n hi·ªáu l·ª±c" -> "‚úÖ";
                case "H·∫øt h·∫°n" -> "‚è∞";
                case "Ch·∫•m d·ª©t" -> "‚ùå";
                default -> "üìÑ";
            };

            sb.append(String.format("""
                üìÑ **H·ª£p ƒë·ªìng #%s:** %s
                ‚îú‚îÄ üìã Lo·∫°i: %s
                ‚îú‚îÄ üìÖ Th·ªùi h·∫°n: %s ‚Üí %s
                ‚îú‚îÄ üí∞ L∆∞∆°ng c∆° b·∫£n: %s VNƒê
                ‚îî‚îÄ üìä Tr·∫°ng th√°i: %s %s
                
                """,
                    safeGetString(contract, "MaHopDong"),
                    emoji,
                    safeGetString(contract, "LoaiHopDong"),
                    formatDate(contract.get("NgayBatDau")),
                    formatDate(contract.get("NgayKetThuc")),
                    formatCurrency(contract.get("LuongCoBan")),
                    trangThai,
                    emoji
            ));
        }

        return sb.toString();
    }

    private String formatAllowanceInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üíº Ch∆∞a c√≥ th√¥ng tin ph·ª• c·∫•p.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üíº **PH·ª§ C·∫§P - %s**\n\n", userName));

        BigDecimal totalAllowance = BigDecimal.ZERO;

        for (Map<String, Object> allowance : data) {
            BigDecimal mucTien = getBigDecimal(allowance.get("MucTien"));
            totalAllowance = totalAllowance.add(mucTien);

            sb.append(String.format("""
                üí∞ **%s:**
                ‚îú‚îÄ üíµ M·ª©c ti·ªÅn: %s VNƒê
                ‚îú‚îÄ üìÖ T·ª´ ng√†y: %s
                ‚îî‚îÄ üìÖ ƒê·∫øn ng√†y: %s
                
                """,
                    safeGetString(allowance, "TenPhuCap"),
                    formatCurrency(mucTien),
                    formatDate(allowance.get("NgayBatDau")),
                    formatDate(allowance.get("NgayKetThuc"))
            ));
        }

        sb.append(String.format("üí∞ **T·ªïng ph·ª• c·∫•p:** %s VNƒê/th√°ng", formatCurrency(totalAllowance)));

        return sb.toString();
    }

    private String formatBonusInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "üéÅ Ch∆∞a c√≥ th√¥ng tin th∆∞·ªüng.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üéÅ **TH∆Ø·ªûNG - %s**\n\n", userName));

        BigDecimal totalBonus = BigDecimal.ZERO;

        for (Map<String, Object> bonus : data) {
            Object mucTienObj = bonus.get("MucTien");
            if (mucTienObj == null) mucTienObj = bonus.get("MucThuong");

            BigDecimal mucTien = getBigDecimal(mucTienObj);
            totalBonus = totalBonus.add(mucTien);

            sb.append(String.format("""
                üèÜ **%s:**
                ‚îú‚îÄ üí∞ S·ªë ti·ªÅn: %s VNƒê
                ‚îî‚îÄ üìÖ Ng√†y th∆∞·ªüng: %s
                
                """,
                    safeGetString(bonus, "TenThuong"),
                    formatCurrency(mucTien),
                    formatDate(bonus.get("NgayThuong"))
            ));
        }

        sb.append(String.format("üéä **T·ªïng th∆∞·ªüng:** %s VNƒê", formatCurrency(totalBonus)));

        return sb.toString();
    }

    private String formatViolationInfo(List<Map<String, Object>> data, String userName) {
        if (data.isEmpty()) return "‚úÖ B·∫°n ch∆∞a c√≥ vi ph·∫°m n√†o.";

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("üö´ **VI PH·∫†M - %s**\n\n", userName));

        BigDecimal totalFine = BigDecimal.ZERO;

        for (Map<String, Object> violation : data) {
            BigDecimal soTienPhat = getBigDecimal(violation.get("SoTienPhat"));
            totalFine = totalFine.add(soTienPhat);

            sb.append(String.format("""
                ‚ö†Ô∏è **Vi ph·∫°m #%s:**
                ‚îú‚îÄ üö´ Lo·∫°i: %s
                ‚îú‚îÄ üìÖ Ng√†y: %s
                ‚îú‚îÄ üìù M√¥ t·∫£: %s
                ‚îú‚îÄ ‚öñÔ∏è H√¨nh th·ª©c ph·∫°t: %s
                ‚îú‚îÄ üí∞ S·ªë ti·ªÅn ph·∫°t: %s VNƒê
                ‚îî‚îÄ üë§ Ng∆∞·ªùi quy·∫øt ƒë·ªãnh: %s
                
                """,
                    safeGetString(violation, "MaViPham"),
                    safeGetString(violation, "LoaiViPham"),
                    formatDate(violation.get("NgayViPham")),
                    safeGetString(violation, "MoTa"),
                    safeGetString(violation, "HinhThucPhat"),
                    formatCurrency(soTienPhat),
                    safeGetString(violation, "NguoiRaQuyetDinh")
            ));
        }

        sb.append(String.format("üí∏ **T·ªïng ti·ªÅn ph·∫°t:** %s VNƒê", formatCurrency(totalFine)));

        return sb.toString();
    }

    private String formatTeamInfo(List<Map<String, Object>> data) {
        if (data.isEmpty()) return "üë• Kh√¥ng c√≥ th√¥ng tin team.";

        StringBuilder sb = new StringBuilder();
        sb.append("üë• **TH√îNG TIN TEAM**\n\n");

        for (Map<String, Object> member : data) {
            sb.append(String.format("‚Ä¢ **%s** - %s - %s\n",
                    safeGetString(member, "HoTen"),
                    safeGetString(member, "TenChucVu"),
                    safeGetString(member, "Email")
            ));
        }

        sb.append(String.format("\nüë• **T·ªïng c·ªông:** %d th√†nh vi√™n", data.size()));

        return sb.toString();
    }

    // ===== HELPER METHODS =====

    private String formatDate(Object dateObj) {
        if (dateObj == null) return "N/A";

        try {
            if (dateObj instanceof LocalDate) {
                return ((LocalDate) dateObj).format(DATE_FORMATTER);
            } else if (dateObj instanceof LocalDateTime) {
                return ((LocalDateTime) dateObj).toLocalDate().format(DATE_FORMATTER);
            } else if (dateObj instanceof java.sql.Date) {
                return ((java.sql.Date) dateObj).toLocalDate().format(DATE_FORMATTER);
            } else if (dateObj instanceof java.sql.Timestamp) {
                return ((java.sql.Timestamp) dateObj).toLocalDateTime().toLocalDate().format(DATE_FORMATTER);
            }
            return dateObj.toString();
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot format date: '{}', returning as string", dateObj);
            return dateObj.toString();
        }
    }

    private String formatCurrency(Object amount) {
        if (amount == null) return "0";

        BigDecimal value = getBigDecimal(amount);
        return String.format("%,d", value.longValue());
    }

    private BigDecimal getBigDecimal(Object value) {
        if (value == null) return BigDecimal.ZERO;

        try {
            if (value instanceof BigDecimal) {
                return (BigDecimal) value;
            } else if (value instanceof Number) {
                return BigDecimal.valueOf(((Number) value).doubleValue());
            } else {
                String str = value.toString().trim();
                if ("N/A".equals(str) || str.isEmpty()) return BigDecimal.ZERO;
                return new BigDecimal(str);
            }
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è Cannot parse as BigDecimal: '{}', returning 0", value);
            return BigDecimal.ZERO;
        }
    }

    private String getLateSeverity(int lateCount) {
        if (lateCount >= 10) return "üö® Nghi√™m tr·ªçng";
        if (lateCount >= 5) return "‚ö†Ô∏è C·∫£nh b√°o";
        if (lateCount >= 2) return "üü° Ch√∫ √Ω";
        return "üü¢ B√¨nh th∆∞·ªùng";
    }

    private double calculateOvertimeRatio(Map<String, Object> analysis) {
        BigDecimal totalSalary = getBigDecimal(analysis.get("TongChiPhiLuong"));
        BigDecimal totalOvertime = getBigDecimal(analysis.get("TongTienTangCa"));

        if (totalSalary.compareTo(BigDecimal.ZERO) > 0) {
            return totalOvertime.multiply(BigDecimal.valueOf(100))
                    .divide(totalSalary, 2, BigDecimal.ROUND_HALF_UP).doubleValue();
        }
        return 0.0;
    }

    private String getOvertimeAssessment(double overtimeRatio) {
        if (overtimeRatio > 20) return "Qu√° cao - c·∫ßn xem x√©t";
        if (overtimeRatio > 10) return "Cao - theo d√µi";
        if (overtimeRatio > 5) return "B√¨nh th∆∞·ªùng";
        return "Th·∫•p - t·ªët";
    }

    private String getCostAssessment(BigDecimal costPerEmployee) {
        long cost = costPerEmployee.longValue();
        if (cost > 50000000) return "Cao";
        if (cost > 30000000) return "Trung b√¨nh";
        return "H·ª£p l√Ω";
    }

    private String getRecommendation(double overtimeRatio, BigDecimal costPerEmployee) {
        if (overtimeRatio > 15) {
            return "‚Ä¢ Xem x√©t t·ªëi ∆∞u h√≥a quy tr√¨nh l√†m vi·ªác\n‚Ä¢ Tuy·ªÉn th√™m nh√¢n vi√™n n·∫øu c·∫ßn thi·∫øt";
        }
        if (costPerEmployee.longValue() > 40000000) {
            return "‚Ä¢ ƒê√°nh gi√° l·∫°i c∆° c·∫•u l∆∞∆°ng\n‚Ä¢ T·ªëi ∆∞u h√≥a chi ph√≠ nh√¢n s·ª±";
        }
        return "‚Ä¢ Duy tr√¨ hi·ªáu qu·∫£ hi·ªán t·∫°i\n‚Ä¢ Theo d√µi c√°c ch·ªâ s·ªë ƒë·ªãnh k·ª≥";}
    // ‚úÖ ADD MISSING METHODS
    private String translateColumnName(String columnName) {
        return switch (columnName.toLowerCase()) {
            // Employee columns
            case "manhanvien" -> "M√£ nh√¢n vi√™n";
            case "hoten" -> "H·ªç t√™n";
            case "email" -> "Email";
            case "gioitinh" -> "Gi·ªõi t√≠nh";
            case "ngaysinh" -> "Ng√†y sinh";
            case "sdt" -> "SƒêT";
            case "diachi" -> "ƒê·ªãa ch·ªâ";
            case "trinhdohocvan" -> "Tr√¨nh ƒë·ªô";
            case "luonghientai" -> "L∆∞∆°ng hi·ªán t·∫°i";
            case "trangthai" -> "Tr·∫°ng th√°i";
            case "trangthailamviec" -> "Tr·∫°ng th√°i l√†m vi·ªác";

            // Contract columns
            case "mahopdong" -> "M√£ h·ª£p ƒë·ªìng";
            case "loaihopdong" -> "Lo·∫°i h·ª£p ƒë·ªìng";
            case "ngaybatdau" -> "Ng√†y b·∫Øt ƒë·∫ßu";
            case "ngayketthuc" -> "Ng√†y k·∫øt th√∫c";
            case "luongcoban" -> "L∆∞∆°ng c∆° b·∫£n";

            // Department columns
            case "tenphongban" -> "T√™n ph√≤ng ban";
            case "tenchucvu" -> "Ch·ª©c v·ª•";
            case "tongsogioteangca" -> "T·ªïng gi·ªù tƒÉng ca";
            case "tongtienthuong" -> "T·ªïng ti·ªÅn th∆∞·ªüng";
            case "tongtinephat" -> "T·ªïng ti·ªÅn ph·∫°t";

            // Bonus columns
            case "tenthuong" -> "T√™n th∆∞·ªüng";
            case "mucthuong" -> "M·ª©c th∆∞·ªüng";
            case "ngaythuong" -> "Ng√†y th∆∞·ªüng";

            // Salary columns
            case "tongthuenhap" -> "T·ªïng thu nh·∫≠p";
            case "tientangca" -> "Ti·ªÅn tƒÉng ca";
            case "thuethunhap" -> "Thu·∫ø thu nh·∫≠p";
            case "thang" -> "Th√°ng";
            case "nam" -> "NƒÉm";

            // Violation columns
            case "solanvipham" -> "S·ªë l·∫ßn vi ph·∫°m";
            case "loaivipham" -> "Lo·∫°i vi ph·∫°m";
            case "sotienphat" -> "S·ªë ti·ªÅn ph·∫°t";
            case "ngayvipham" -> "Ng√†y vi ph·∫°m";

            default -> columnName;
        };
    }
    private boolean isKeyField(String columnName) {
        String lower = columnName.toLowerCase();
        return lower.contains("hoten") || lower.contains("ten") ||
                lower.contains("ma") || lower.contains("luong") ||
                lower.contains("email") || lower.contains("chucvu") ||
                lower.contains("phongban") || lower.contains("ngay") ||
                lower.contains("trang") || lower.contains("loai") ||
                lower.contains("muc") || lower.contains("so");
    }
    @SuppressWarnings("unused")
    private long safeParseLongWrapper(Object value) {
        return safeParseLong(value);
    }
}